ðŸ“Œ PUNTO DE PARTIDA: Revisar comportamiento de `executor`.

1. âœ… Validar entrada a `executor`
   - âœ… Confirmar que `all.tokens` y `program` no son NULL.
   - âœ… Verificar que `find_first_command()` devuelve un token vÃ¡lido de tipo `command`.
   - âœ… construir args solo en caso de tener first_command -> casos en los que no tenemos comandos pero si redirreciones. 
   - âœ… ifs para solo redirecciones, 1 comando/builting, pipes

2. âœ… Validar preparaciÃ³n de argumentos
   - âœ… Confirmar que `build_args()` llena correctamente `all.exec->args`.
   - âœ… Verificar si `all.exec->args[0]` contiene el comando esperado.
   - âœ… Confirmar que libera memoria previa (`ft_free_matrix()`).

3. âœ… Contar correctamente los comandos y pipes
   - âœ… Verificar salida de `count_type_tokens()` para `pipe_type` y `command`.
   - âœ… Confirmar que `num_cmds` y `num_pipes` son correctos en todos los casos.

4.0  âœ… exit o return depiendiendo si es padre o  hijo.
  âœ… padre
  âœ… hijo
11. âœ… revisar error_and_return-> dan mucho dramas con la memoria -> define

-------------------------------------
4.0.1  âœ… #âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ”€â¤âžµâ€¢âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâ”€â”€  eliminacion de tokens vacios de args
   NecesitÃ¡s distinguir si un token vacÃ­o proviene de:
   1. expansiÃ³n de variable â†’ eliminar token si resulta vacÃ­o
   2. comillas explÃ­citas â†’ preservar como token vacÃ­o literal
   from_expansion = ftue; -> Si el token no estaba entre comillas, y la expansiÃ³n da cadena vacÃ­a â†’ no crear args
   tokens->was_quoted = true; -> Si estaba entre comillas (ej: "$VAR" o '$VAR') â†’ sÃ­, crear args con "" y was_quoted = true
-------------------------------------

4.1 [ ] Ejecutar comandos sin pipes (proceso hijo sin pipes) -> falla valgrind
   - [ ] comandos validos
   - [ ] comandos "malos" -> ver error y valgring
   - [ ] norma funciones:
         - [ ] executor.c
         - [ ] get_path_execve.c
         - [ ] pipes.c
         - [ ] redirs.c
   - [ ] valgrind -> frees

   - [ ] Si `num_pipes == 0`, asegurarse de que `execute_single_command()` entra correctamente.
   - [ ] mensajes de error en los comandos solos
   - [ ] Dentro de esta funciÃ³n:
       - [ ] Verificar comportamiento de `apply_redirections()`.
       - [ ] Confirmar si es builtin o execve.
       - [ ] Si execve, testear `fork_and_execute_single_cmd()`:
           - [ ] Confirmar que el hijo ejecuta correctamente `exec_cmd()`.
           - [ ] Validar `get_executable_path()` y `execve()`.
   - [ ] valgrind -> frees
   - [ ] testeo

4.2 âœ… Ejecutar builtings sin pipes (proceso padre sin pipes)
   - âœ… exec_builtin() 
   - âœ… is_builting() 
   - âœ… TODAS LAS BUILTINS:  testear si program->last_exit_status = 0; altera resultado + return (0);

   - âœ… cd()  
         - âœ…  cd + << ll -> no borra archivos temporales.
         - âœ… cd -> procesosos padre con return e hijo con exit
            - âœ… cd en proceso padre -> valgrind
            - âœ… cd en proceso hijo -> valgrind
         - âœ… cd -> bash: ,: No such file or directory -> cd , (corregir error_msg);
   - âœ… echo() 
   - âœ… env()
         - [ ] revisar si estan bien los datos de env
   - âœ… export() 
         - âœ… enlazar $VARS con export
   - âœ… unset()
   - âœ… exit() 
   - âœ… pwd()

   - [ ] mensajes de error en los builtins solos
   - [ ] valgrind -> frees
   - [ ] testeo

4.3  [ ] testeo + valgrind
          - [ ]  Valgrind solo redirs
          - [ ]  Valgrind solo execve
          - [ ]  Valgrind solo builtins
   - [ ] testeo comandos 
   - [ ] testeo builtings
   - [ ] VALGRIND A OK

4.4 âœ… testear bien los here-doc, a veces no liberan los archivos temporales y no se por que. 

-------------------------------------
5. [ ] Ejecutar comandos con pipes
   - [ ] Confirmar entrada a `executor_loop()`.
   - [ ] Validar creaciÃ³n de pipes (`setup_pipes()`).
   - [ ] Confirmar creaciÃ³n de hijos con `fork_command()`:
       - [ ] Redirecciones (`apply_redirections()`).
       - [ ] Configurar stdio (`setup_redirects()`).
       - [ ] Ejecutar comando builtin o `exec_cmd()`.
   - [ ] Confirmar cierre de pipes en padre (`close_unused_pipes_in_parent()`).
   - [ ] Confirmar `wait_for_children()` recoge todos los hijos y actualiza `last_exit_status`.

5.1. [ ] Ejecutar comandos con pipes y redirecciones
   - [ ] si un hijo falla, el hijo termina con exit(failure_status)

6. [ ] Limpieza final
   - [ ] Confirmar cierre de todos los file descriptors (`close_fds()` y `free_pipes()`).
   - [ ] Confirmar liberaciÃ³n de `all.exec->args` si es necesario.

7. ðŸ§ª DEBUGGING sugerido
   - [ ] Activar logs `DEBUG:` en cada funciÃ³n clave.
   - [ ] Confirmar valores intermedios: tokens, args, path, PID.
   - [ ] Validar salidas de `execve()` y `waitpid()`.

8. ðŸ§¼ ERRORES comunes a testear
   - [ ] Comando que no existe.
   - [ ] Comando sin permisos.
   - [ ] Comando que es un directorio.
   - [ ] Redirecciones invÃ¡lidas.
   - [ ] Pipes mal cerrados o duplicados.


9. [ ] quitar tokens-> own_command -> se usa is_builting().
10. [ ] here doc no libera con builtings los archivos temporales

12. [ ] norma todo
   - [ ] valfrind todo
   - [ ] fts abiertos, pid abiertos, 
-------------------------------------------------

//#âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ”€â¤âžµâ€¢âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâ”€â”€ malloc_parcer: â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâ¤âžµâ€¢âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâž”#

    â”œâ”€â”€ parcer
    â”‚Â Â  â”œâ”€â”€ check_spaces_line.c  + _testeo_malloc
    â”‚Â Â  â”œâ”€â”€ check_spaces_line_utils.c  + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ check_syntax_error_token.c âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ free_structs.c
    â”‚Â Â  â”œâ”€â”€ free_utils.c
    â”‚Â Â  â”œâ”€â”€ ft_split_with_quotes.c + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ get_prompt.c + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ init_list.c + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ init_structures.c + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ tokenizer_utils.c + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ var_check_expand.c  + âš ï¸_testeo_malloc
    â”‚Â Â  â”œâ”€â”€ var_expand_core.c  + âš ï¸_testeo_malloc
    â”‚Â Â  â””â”€â”€ var_lookup.c  + âš ï¸_testeo_malloc


//#âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ”€â¤âžµâ€¢âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâ”€â”€ malloc_exec + builtins + env + args + redirecciones: â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâ¤âžµâ€¢âžµâ¤â”€â”€â•Œâ•Œâž£â‹†âž£â•Œâ•Œâž”#

------------------------------------------------------------------------------------------------------------------------------------
	//FASE_3_V2
	// ðŸ”¸  âœ’ renderizar reenicio de line y los demas_reinicios en minishell_loop().
		// ðŸ”¸  âœ’  quitar break y hacer las fucniones de reinicio de line y lo demÃ¡s. 
		// ðŸ”¸  âœ’  recisar fucniones que se usan o no: todo 
		// ðŸš©_TESTEO_NORMA
		// ðŸš©_TESTEO_TOKENIZACION
		// ðŸš©_TESTEO_EJECUCION+BUILDINGS
		// ðŸš©_TESTEO_SEÃ‘ALES
		// ðŸš©_TESTEO_HISTORIAL
		// ðŸš©_TESTEO_MEMORY_LEAKS 
		// ðŸš©_DESCRIPCIONES_FUCNIONES



-------------------------------------------------
//1. EjecuciÃ³n de Comandos (generales):
	//parse_command() â€“ Parsea la lÃ­nea de comandos en estructuras Ãºtiles.
	//execute_command() â€“ Determina si es builtin o externo y lo ejecuta.
	//fork_and_execve() â€“ Maneja el fork() y llama a execve() si no es builtin.


// 2. Builtins
	//exec_builtin() 
	//is_builting() 
	//cd() 
	//echo() 
	//env()
	//export()
	//unset()
	//exit() 
	//pwd()

// 3. Pipes
	pipe(), dup2(), close()
	ConexiÃ³n entre stdout de un comando y stdin del siguiente
	Recorrido de comandos en una pipeline con manejo de procesos hijos

//4. Redirecciones




//5. Path y execve()
	Resolver comandos externos:
	Buscar en $PATH
	Comprobar permisos con access()
	Armar path completo
	Llamar a execve() con argv y envp


//6. GestiÃ³n de Procesos
	fork() y esperar hijos:
	wait() / waitpid() para sincronizaciÃ³n
	Control de status (WIFEXITED, etc.)
	Control de procesos en pipelines (varios hijos simultÃ¡neos)

// 7. Variables de Entorno
	Manejo de env, export, unset
	Probablemente uses una lista ligada o tabla hash para las variables internas de entorno
	Al llamar a execve(), convertir tus variables internas a char **envp

//8. RestauraciÃ³n del Estado
	Restaurar stdin / stdout despuÃ©s de redirecciones
	Cerrar todos los pipes abiertos
	Free de estructuras temporales


//9. Errores y SeÃ±ales
	Mensajes de error (comando no encontrado, permisos, etc.)
	Manejo de seÃ±ales (SIGINT, SIGQUIT)
	Evitar que el shell se cierre por Ctrl+C


//SEÃ‘ALES:
Ctrl-\         -> SIGQUIT -> Mata el proceso y hace un core dump (si estÃ¡ permitido). -> Quit (core dumped)
ctrl-C         -> SIGINT (Signal Interrupt) -> imprime una nueva entrada en una lÃ­nea nueva. -> ^C 
ctrl-D         -> EOF (no seÃ±al) -> termina el shell. -> Cierra el shell si se presiona en vacÃ­o

Ejemplo en el shell:
   $              # Esperando input
   <Ctrl-D>       # El usuario pulsa Ctrl-D
   # Shell se cierra


Ejemplo en cat
   $ cat
   hola
   mundo
   <Ctrl-D>        # Termina la entrada, `cat` finaliza y se imprime lo que escribiste
   hola
   mundo
   $





