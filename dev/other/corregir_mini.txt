âš ï¸_PTE TESTEO
âŒ_NO FUNCIONA
âœ…_OK

definitely lost: Memoria que fue reservada pero nunca liberada y ya no tienes cÃ³mo acceder a ella. Â¡Esto es una fuga real!
indirectly lost: Memoria accesible solo a travÃ©s de punteros que ya estÃ¡n perdidos.
still reachable: Memoria que aÃºn estÃ¡ referenciada cuando el programa termina. No es una fuga crÃ­tica si se libera al final, pero sÃ­ es buena prÃ¡ctica liberarla.
suppressed: Ignorada por reglas de Valgrind.

//ğŸ”¶still reachable:
allocate_pipe_fds
	==55354== 0 bytes in 1 blocks are still reachable in loss record 1 of 23
	==55354==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
	==55354==    by 0x10FEC1: allocate_pipe_fds (ejecucion.c:585)
	==55354==    by 0x10FFC4: setup_pipes (ejecucion.c:612)
	==55354==    by 0x110B51: executor (ejecucion.c:1008)
	==55354==    by 0x10B885: minishell_loop (minishell_loop.c:102)
	==55354==    by 0x10BB0D: main (main.c:29)

	
init_meta_struct
init_prompt_or_fail
init_here_struct
get_line_prompt
init_exec
init_list -> lista de tokens

exec_cmd:
	==54308==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
	==54308==    by 0x112B71: ft_strdup (in /home/mzolotar/42_School_temp_rep/copia_mini_borrador/minishell)
	==54308==    by 0x10F69D: fill_args (ejecucion.c:354)
	==54308==    by 0x10F75F: build_args (ejecucion.c:376)
	==54308==    by 0x10FBEE: exec_cmd (ejecucion.c:523)
	==54308==    by 0x11093E: fork_command (ejecucion.c:938)
	==54308==    by 0x110A10: executor_loop (ejecucion.c:960)
	==54308==    by 0x110B8D: executor (ejecucion.c:1013)
	==54308==    by 0x10B885: minishell_loop (minishell_loop.c:102)
	==54308==    by 0x10BB0D: main (main.c:29)

	==54308== 
	==54308== 16 bytes in 1 blocks are still reachable in loss record 9 of 23
	==54308==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
	==54308==    by 0x10F73A: build_args (ejecucion.c:373)
	==54308==    by 0x10FBEE: exec_cmd (ejecucion.c:523)
	==54308==    by 0x11093E: fork_command (ejecucion.c:938)
	==54308==    by 0x110A10: executor_loop (ejecucion.c:960)
	==54308==    by 0x110B8D: executor (ejecucion.c:1013)
	==54308==    by 0x10B885: minishell_loop (minishell_loop.c:102)
	==54308==    by 0x10BB0D: main (main.c:29)

==54308== 376 bytes in 1 blocks are still reachable in loss record 17 of 23
==54308==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==54308==    by 0x11078B: allocate_matrix (ejecucion.c:880)
==54308==    by 0x1107C0: env_list_to_matrix (ejecucion.c:893)
==54308==    by 0x10FC1F: exec_cmd (ejecucion.c:526)
==54308==    by 0x11093E: fork_command (ejecucion.c:938)
==54308==    by 0x110A10: executor_loop (ejecucion.c:960)
==54308==    by 0x110B8D: executor (ejecucion.c:1013)
==54308==    by 0x10B885: minishell_loop (minishell_loop.c:102)
==54308==    by 0x10BB0D: main (main.c:29)

//ğŸ”¶------------------------------ MALLOC -----------------ğŸ”¶//
//ğŸ”¶----------------PROGRAM


//ğŸ”¶----------------PROMPT
*prompt = malloc(sizeof(t_prompt));
prompt->hostname = ft_strdup(hostname_raw);
prompt->hostname = ft_strdup("unknown");

//ğŸ”¶----------------LINE


//ğŸ”¶----------------meta


//ğŸ”¶----------------exec
exec->pipe_fds = malloc(sizeof(int *) * exec->num_pipes); ( en allocate_pipe_fds) -> 
exec->pipe_fds[i] = malloc(sizeof(int) * 2); en allocate_single_pipe -> free_partial_pipes(exec, i);

//ğŸ”¶----------------HERE


//ğŸ”¶----------------TOKEN


//ğŸ”¶----------------TOKENS





//ğŸ”¶------------------------------ VALGRIND:: -----------------ğŸ”¶//
âš ï¸Revisar primero redirecciones. Y fd
âš ï¸Here q no se cierra
âš ï¸AÃ±adir sani a makefile - En scripts
âš ï¸revisar si se liberan los pipes 
âš ï¸revisar si se cierran los fd
âš ï¸revisar las redirecciones y los here. 
âš ï¸revisar las funciones que menciona valgrind
âš ï¸ revisar rutas de fallos de comandos
âš ï¸revisar la norma y a ver si asi enconramos los fallitos de valgrind
âš ï¸ revisar todo archivo ejecucion y los flujos 


âš ï¸How to improve this:
Review init, setup and free functions:
Most "still reachable" blocks come from initialization functions like init_all_structs, init_meta_struct, init_prompt, init_here_struct, and environment-related functions like create_env_list.
Free allocated structures on program exit:
Make sure you have a function that cleans up all allocated data (e.g., linked lists, arrays, strings) before exiting the program.
For dynamic strings and arrays:ft_strdup, ft_split, ft_substr, ft_strjoin return heap-allocated memory.
Track all these allocations and free them when no longer needed.
Pipes and file descriptors arrays:
Allocations inside allocate_pipe_fds and setup_pipes must also be freed at program termination or after use.

âš ï¸Quick checklist for cleanup:
Add a "cleanup" function that:
Frees the environment list (create_env_list allocations).
Frees all linked list nodes created by add_node, init_list.
Frees all strings duplicated by ft_strdup and allocated by ft_split.
Frees arrays like pipes and command argument lists (allocate_pipe_fds, build_args).
Frees prompt-related allocations.
Frees here-doc related allocations (init_here_struct).
Call this cleanup function in main before returning.

âš ï¸
void cleanup(t_shell *shell) {
    free_env_list(shell->env);
    free_token_list(shell->tokens);
    free_pipes(shell->pipes);
    free_prompt(shell->prompt);
    free_here_docs(shell->here_docs);
    // Free other dynamic allocations
}



//ğŸ”¶------------------------------ Cambiado: -----------------ğŸ”¶//
//----------------- redirections -----------------//


//----------------- Ejecucion -----------------//



//----------------- Builtings -----------------//
âœ… reajustado exit, habia casos que fallaban. 
âŒ cd solo con una ruta relativa o absoluta
âŒ pwd
âŒ env sin opciones o argumentos -> no funciona con redirecciones y pipes: env | sort | grep HOME -> no gestiona pipes
esta vercion coge las redirecciones:
void	builtin_env(t_program *program, t_all all, t_tokens *cmd)
{
	t_tokens	*tmp;

	tmp = cmd->next;
	while (tmp && tmp->type != pipe_type)
	{
		if (tmp->type == argument && tmp->content && tmp->content[0] != '\0')
		{
			ft_putstr_fd("env: â€˜", STDERR_FILENO);
			ft_putstr_fd(tmp->content, STDERR_FILENO);
			ft_putendl_fd("â€™: invalid argument", STDERR_FILENO);
			return ;
		}
		tmp = tmp->next;
	}
	print_env(program->env, all.exec->outfile);
}
â—¦ export sin opciones.
â—¦ unset sin opciones.

//------------------ TESTEO ------------------//
//----------- Ejecucion --------------//
âŒ   ./ejecutable_con_permisos_ok.sh

here_doc -> falla con cd -> no libera temporales 

âš ï¸   command  > path_name arg 
âš ï¸   command  < path_name arg 
âš ï¸   command  >> path_name arg
âš ï¸   command  << delimiter arg

//----------- Builtings --------------//
âœ…_PTE_TTO_ENERAL: echo con la opciÃ³n -n.
âœ…_PTE_TTO_ENERAL: exit sin opciones.
âŒ â—¦ pwd sin opciones. -> redirecciones y pipes fallan
âŒ â—¦ cd solo con una ruta relativa o absoluta. -> cd + here_doc falla y  fallos con mensajes de error + fallos de valgrind
âŒ â—¦ env sin opciones o argumentos.
-> env debe permitir estos casos:
	 env > file 
	 env >> file
	 env << ls
	 env | tee file.txt | wc -l
	 env | tee file.txt | wc -w
	 env | tee file.txt | wc -c
	 env | grep home | tee file.txt
	 env | sort | grep HOME
	 env | grep PATH

 -> env no debe permitir ninguno de estos:
	env VAR1=val1
	env VAR1=val1 VAR2=val2
	env VAR1=val1 ls
	env VAR1=val1 VAR2=val2 echo hola
	env -i
	env --ignore-environment
	env -u VAR1
	env hola
	env foo=bar otra
	env /bin/ls


âŒ export sin opciones.
	âŒ por que imprime env?
	âŒ por que -> Segmentation fault (core dumped) (ignored)
	âŒ por que fucnionan opciones que no deberian?
	âŒ por que no funcionan comandos que deberian: export
	âš ï¸ no se pillan las variebles metidas por export -> sincronizar tokenizacion vars con env y export

âŒ unset sin opciones.
	unset PATH:
		-âŒ sigue imprimirndo env  y debe dar: -bash: env: No such file or directory
		-âŒ error de bash incorecto si metemos comando tipo ls



//ğŸ”¶------------------------------ Corregir: -----------------ğŸ”¶//

âŒ1. reajustar ejecucion al cambiar las fucniones por la norma ya no coge todos los comandos que debe. CAMBIAR Y TESTEAR.
		âœ…lalalal                 -> lalalal: command not found -> 127 
		âœ…hola.sh                 -> hola.sh: command not found -> 127
		âŒ./hola.sh               ->  -> 0		 âŒ->	(archivo .sh con permisos)
		âŒ'./hola.sh'             ->  -> 0
		âœ…./minishell             ->  -> 0
		âŒ./no_existesh           -> bash: ./hola_1sh: No such file or directory -> 127  âŒ-> revisar last_exit_status sale 126, no se por que
		âœ…./test                  -> bash: ./test: Is a directory-> 126 
		âœ…./hola_1.sh             ->  bash: ./hola_1.sh: Permission denied  -> 126 (archivo .sh sin permisos)
		âŒ./hola.sh echo hola     ->  -> 0

âŒ2. correguir builting PWD:
		âœ… pwd >> file.txt
		âœ… pwd > out.txt 
		âœ… pwd > 
		âœ… pwd |
		âœ… pwd | cat                   # Muestra la ruta, pasada por pipe a cat
		âŒ pwd | cat > file.txt        # La ruta actual escrita en `file.txt`
		âŒ pwd | wc -c                 # Cuenta caracteres del path
		âŒ pwd | wc -l                 # Debe dar 1

		touch file; chmod 444 file
		âŒ pwd > file                 # Bash: Permission denied -> last_exit_status = 1  . -> âŒ no pilla bien el error y el mensaje no corresponde

		âœ… (pwd)                     # deberÃ­a funcionar si implementas subshells
		âŒ pwd | grep home | tee file.txt
		âŒ pwd > file.txt | cat file.txt   
		âŒ pwd | tee file.txt | wc -l
		âœ… pwd | grep "/" | cat          # Pipe con grep y cat
		âŒ_. La norma. 
		âŒ_. errores valgrind. 

âŒ3. void exit_shell(t_program *program, t_all all, char *msg, int status) 
	âŒ cortregir los mensajes de error 
	âŒ revisar la ruta de ejecucion y las liberacions, con valgrind pasan cosas raras

//ğŸ”¶------------------------------ Valgrind: -----------------ğŸ”¶//
âœ… echo + exit
	âœ… echo mundo << la << ls
âœ… exit
	âœ… exit << la << ls
âœ… pwd + exit
	âœ… pwd << la << ls
	
âŒ cd 
	âœ… cd + exit -> falla con valgring -> reajustado
	âœ… cd + error de redireccion -> falla last_exit_status -> reajustado
	âœ… cd + redireccion sin error
	âœ… cd -> comandos incorrectos: corregido segun subject
		âœ… cd 
		âœ… cd -

	âŒ cd + here -> no elimina los temporales de here, pero si los elimina con exec-> wtf  -> 
		âŒ cd test/ << la << ls
	âŒ cd + error de redireccion -> falla mensaje de error debe llebar bash: ...
	âŒ cd + error de redireccion -> falla valgrind
	âŒ cd + error agd de cd ya no funciona cd. 
	
	
	
	

export + exit
unset + exit



//ğŸ”¶------------------------------ Revisar:-----------------ğŸ”¶//
âš ï¸ ft_putstr_fd("minishell: export: `", STDERR_FILENO);  // âš ï¸ "minishell: " -> revisar el formato general de mini para poner o no poner mensaje minishell que haya coherencia a nivel global del proyecto
âš ï¸ perror, ft_putendl_fd y todas las demas impresiones de mini simpre en INGLES -> NORMA. revisar cod ejec y builtings
âš ï¸ void add_env_var_2(t_env **env, char *key, char *value) -> NORMA-> ternarios Not
