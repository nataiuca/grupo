âœ… FUNCIONA:
âŒ BASH_ERROR:
âŒ SINTAX_ERROR
ğŸ”¹
âœ”
ğŸ”¸
âœ’
//minishell_loop()
//    â†“
//    (Leer lÃ­nea, tokenizar, vars, here)
//    â†“
//execute_command(all, program, prompt)
//    â”œâ”€ Si `count_pipe(all->tokens) == 0` (comando Ãºnico):
//   â”‚   â”œâ”€ Si `is_builtin(comando_principal)`:
//    â”‚   â”‚   â”œâ”€ (Aplicar redirecciones de archivo en el padre)
//    â”‚   â”‚   â””â”€ exec_builtin (en el proceso padre)
//    â”‚   â””â”€ Si comando externo:
//    â”‚       â”œâ”€ fork_and_execute_single_cmd (crea un hijo)
//    â”‚       â”‚   â”œâ”€ (En el hijo):
//    â”‚       â”‚   â”‚   â”œâ”€ (Aplicar redirecciones de archivo)
//    â”‚       â”‚   â”‚   â””â”€ execve
//    â”‚       â”‚   â””â”€ (En el padre):
//    â”‚       â”‚       â””â”€ waitpid
//    â””â”€ Si `count_pipe(all->tokens) > 0` (pipeline):
//        â”œâ”€ setup_pipes (crea todos los pipes en el padre)
//        â”œâ”€ Bucle: por cada comando en el pipeline:
//        â”‚   â”œâ”€ fork (crea un hijo)
//        â”‚   â”‚   â”œâ”€ (En el hijo):
//        â”‚   â”‚   â”‚   â”œâ”€ setup_redirects (pipes)
//        â”‚   â”‚   â”‚   â”œâ”€ apply_redirections (archivos)
//        â”‚   â”‚   â”‚   â”œâ”€ Si `is_builtin(comando_hijo)`:
//        â”‚   â”‚   â”‚   â”‚   â””â”€ exec_builtin
//        â”‚   â”‚   â”‚   â””â”€ Si comando externo:
//        â”‚   â”‚   â”‚       â””â”€ execve
//        â”‚   â”‚   â””â”€ (En el padre):
//        â”‚   â”‚       â””â”€ (Cerrar FDs de pipe usados por este hijo)
//        â”œâ”€ close_fds (cerrar todos los pipes restantes en el padre)
//        â””â”€ wait_for_children (esperar a todos los hijos)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

codigo fuente de shell: https://github.com/JMDTol/bash/blob/master/shell.c#L365

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

pasos tokenizacion:

La tokenizaciÃ³n en Bash es el primer paso que realiza el shell al procesar un comando. 
Se encarga de dividir la lÃ­nea de entrada en unidades llamadas tokens, que luego se interpretarÃ¡n como palabras clave, nombres de comandos, argumentos, operadores, etc.

â­ 0. Patron de prioridades a la hora de analizar la linea de comandos:
	ğŸ”¸ 1. separadores: &&, ||, |, &, '\0', '\n' etc. 
	ğŸ”¸ 2. redirecciones <, <<, >, >>, etc.
		2.0 redirecciones numeradas deberan llevar espacio para separarlos en la linea de comando, sino bash ira a separarlo por <<, >>, < o >.
		2.1 '#' debera estar al principio de linea o llevar espacio para que bash lo reconozca como caracter de anotar la linea. 
	ğŸ”¸ 3. comillas 
	ğŸ”¸ 4. espacios 

	âŒ tokenizacion "comillas - espacios" va muy junto. 
	âŒ ojo con estos casos. Combinamos tokenizacion de espacios y comillas:
		â†’ echo hola mundo 					â†’ hola mundo
		â†’ echo hola mundo ls 				â†’ hola mundo ls
		â†’ echo "hola" "mundo" 				â†’ hola mundo
		â†’ echo "hola" "mundo" ls			â†’ hola mundo ls
		â†’ echo "hola" "mundo" && ls 		â†’ (hasta que no encuentra separador no para de meter los datos como argumentos)
		â†’ echo "hola""mundo"&& ls			â†’ holamundo + ls command (&& para separar ls, y al no haber espacios como separador las comillas se quitan y tenemos un token sin espacios: holamundo )
	
	ğŸ”¹ comandos que se comportan como echo: echo, printf, ls, rm, cp, mv, kill, ps, grep, find, awk, sed, chmod, chown, ping, curl, 
	ğŸ”¹ comandos que se comportan como ls:
		âœ… Comandos de salida de texto:
		â†’ echo â†’ Muestra todos los argumentos concatenados con espacios.
			â†’ echo hola mundo de unicornios 
		â†’ printf â†’ Similar a echo, pero con mÃ¡s control de formato
			â†’ printf "%s\n" hola mundo ls
		âœ… Comandos de manipulaciÃ³n de archivos y directorios
		â†’ ls â†’ Lista mÃºltiples archivos o directorios dados como argumento
			â†’ ls archivo1 archivo2 carpeta1
		â†’ cat â†’ Imprime el contenido de mÃºltiples archivos
			â†’ cat archivo1 archivo2
		â†’ rm â†’ Borra mÃºltiples archivos
			â†’ rm archivo1 archivo2
		â†’ cp â†’ Copia mÃºltiples archivos a un destino
			â†’ cp archivo1 archivo2 carpeta_destino/
		â†’ mv â†’ Mueve mÃºltiples archivos a otro directorio
			â†’ mv archivo1 archivo2 carpeta_destino/
		âœ… Comandos de procesos
		â†’ kill â†’ Acepta mÃºltiples PIDs a la vez
			â†’ kill 1234 5678
		â†’ ps â†’ Puede recibir mÃºltiples opciones como argumentos
			â†’ ps aux
		âœ… Comandos de bÃºsqueda y filtrado
		â†’ grep â†’ Puede recibir mÃºltiples patrones o archivos
			â†’ grep "texto" archivo1 archivo2
		â†’ find â†’ Puede recibir mÃºltiples directorios y opciones
			â†’ find carpeta1 carpeta2 -name "*.txt"
		â†’ awk â†’ Interpreta mÃºltiples argumentos como parte del script.
			â†’ awk '{print $1, $2}' archivo
		â†’ sed â†’ Similar a awk, acepta mÃºltiples argumentos hasta un separador.
			â†’ sed 's/foo/bar/g' archivo
		âœ… Comandos de control de usuarios y permisos
		â†’ chmod â†’ Cambia permisos a mÃºltiples archivos.
			â†’ chmod 644 archivo1 archivo2
		â†’ chown â†’ Cambia dueÃ±o de mÃºltiples archivos.
			â†’ chown usuario:grupo archivo1 archivo2
		âœ… Comandos de redes y conexiÃ³n
		â†’ ping â†’ Puede recibir mÃºltiples argumentos antes de un separador
			â†’ ping -c 4 google.com
		â†’ curl â†’ Acepta mÃºltiples opciones hasta que encuentra un separador
			â†’ curl -o archivo.txt https://example.com

â­ 1. Proceso de TokenizaciÃ³n en Bash:

	ğŸ”¸ 0. â†’ linea vacia: <espacio><espacio><ENTER> â†’ No hay tokens, asÃ­ que no hay comando. Bash simplemente muestra un nuevo prompt sin ejecutar nada.
		// âœ’ esto debe ir al historial
	ğŸ”¸ 0. â†’ <ENTER> â†’ No hay tokens, asÃ­ que no hay comando. Bash simplemente muestra un nuevo prompt sin ejecutar nada.
		// âŒ esto no va al historial
	ğŸ”¸ 0. EliminaciÃ³n de espacios en blanco iniciales y finales. Preparamos 'line' para seguir. El shell ignora espacios, tabs y nuevas lÃ­neas al principio y al final del comando. Esto no afecta a la tokenizaciÃ³n directamente, pero sÃ­ prepara el comando para que sea procesado correctamente. -> revisar f ()-> char *get_line(void);
	ğŸ”¸ 0. "" y '' â†’ se tokeniza y da âŒ BASH_ERROR: Command '' not found. 
	ğŸ”¸ 0. âŒ SINTAX_ERROR
		1. var con caracteres prohibidos	
		2. delimitadores prohibidos sin comillas
		3. comillas abiertas. ver casos bien
		4. <<< (fase 2)
	ğŸ”¸ 1. ExpansiÃ³n de Alias: revisar casos ğŸ¤¯
			1. alias ll='ls -l' 		-> (âŒ SINTAX_ERROR) 								-> tokenizmos con espacios alias
			2. aliasll='ls'				-> (âŒ SINTAX_ERROR) 								-> tokenizmos sin espacios alias
			3. aliasll ='ls'			-> âŒ BASH_ERROR: aliasll: command not found			-> tokeniza aliasll como command
			4. aliasll= 'ls'			-> ejecuta ls y registra ll						 	 -> tokeniza alias ll y ejecuta ls como token independiente

	ğŸ”¸ 2.0 ver si hay o no comillas:
		1. NO HAY COMILLAS (âŒ ft_split da error en este caso, escribir f() nueva de parceo).
			1. primer token comando: (Todo lo que sigue despuÃ©s del comando se considera argumento, hasta que aparezca un separador (|, ;, &&, ||, etc.)). 
			ejemplos de comandos + argumentoS sin comillas (los argumentos no se limitan con espacio o comillas, sino con delimitadores): echo, printf, ls carpeta1 carpeta2, cat archivo1 archivo2, rm archivo1 archivo2, tar -cvf archivo.tar carpeta1 carpeta2, etc. 
				1. tokenizamos siguiendo patron de prioridades ver PTO. 2
			2. primer token redireccion:
				1. ver PTO.2 
		3. SI HAY COMILLAS CERRADAS -> âœ… SEGUIMOS con el pto 2, tokenizamos con espacios y comillas, siguiendo los patrones de prioridades


	ğŸ”¸ 2. DivisiÃ³n en palabras segÃºn reglas de delimitaciÃ³n: espacios o/y comillas. 
	Espacios y comillas: Los espacios separan los tokens, y las comillas permiten que se mantenga una cadena con espacios como un solo argumento. 
	A veces las comillas se quitan tokenizando como comando y no como argumento: "ls"|"wc" "-l" o "ls. Ver reglas tokenizacion con comillas mas adelante. 

		"ls"|"wc" "-l" 					âœ… FUNCIONA:
		ls "-l -1"						âŒ BASH_ERROR: ls: invalid option -- ' '
		"ls""-l""-1"|"wc""-l" 			â†’ si el comando no es valido: ls-l-1: command not found + wc-l: command not found

		1. Espacios como delimitadores: Separan los tokens.
		2. Comillas como delimitadores: 
		ğŸ“› REGLAS DE TOKENIZACION CON COMILLAS ğŸ“›
			
			âœ”  El primer token despuÃ©s de la tokenizaciÃ³n que NO sea una redirecciÃ³n/here_doc (>, <, >>, <<, etc.) es tratado como el comando.
				â†’ hay comandos que por como estan diseÃ±adas no necesitan redireccion, pero con redireccion tambien van a fucnionar:
					cat  â†’  	cat archivo.txt  				â†’  cat < archivo.txt
					sort  â†’ 	sort archivo.txt  				â†’  sort < archivo.txt
					grep  â†’ 	grep palabra archivo.txt  		â†’  grep palabra < archivo.txt
					awk  â†’  	awk '{print $1}' archivo.txt  	â†’  awk '{print $1}' < archivo.txt
					sed  â†’  	sed 's/foo/bar/' archivo.txt  	â†’  sed 's/foo/bar/' < archivo.txt
					wc  â†’  		wc archivo.txt  				â†’  wc < archivo.txt
					uniq  â†’  	uniq archivo.txt  				â†’  uniq < archivo.txt
					head  â†’  	head archivo.txt  				â†’  head < archivo.txt
					tail  â†’  	tail archivo.txt 				â†’  tail < archivo.txt
				â†’ si primer token es una redirecciÃ³n de tipo <: patron "command + redireccion + path_name"
					â†’ < archivo.txt 	â†’ No hay un comando que consuma la entrada, asÃ­ que simplemente Bash abre y cierra el archivo sin hacer nada.

				â†’ si primer token es una redirecciÃ³n de tipo >: patron "command + redireccion + path_name" o patron "redireccion + path_name"
					> test.txt echo hola
					> test.txt

				â†’ si primer token es here_string o here_doc:
					â†’ cuidado a la hora de tokenizar las redirecciones: a veces van sin espacio y valen
					â†’ << DELIMITER 		â†’ âœ… gestionar minishell
					â†’ <<, <, >, >> 		â†’ âŒ BASH_ERROR: bash: syntax error near unexpected token `newline' (falta DELIMITER en el patron: << DELIMITER)
					â†’ <<<  				â†’ âŒ SINTAX_ERROR (no gestionamos here_string en minishell)
					â†’ << .. y << . y 	â†’ âŒ SINTAX_ERROR (como comillas abiertas)
					â†’ <<.. y <<. 	 	â†’ âŒ BASH_ERROR: bash: ..: Is a directory (. y .. se tokeniza como path_name)
					â†’ <<<< ...  		â†’ âŒ BASH_ERROR: -bash: syntax error near unexpected token `<<<' (<<< < no sigu el patron de < path_name)
					â†’ << LIMITER	
						âœ…	<< LIMITER y << "LIMITER"
				â†’ si primer token es command pero ademas le sigue here_string o here_doc: primero se ejecuta << DELIMITER y luego command + arg. puede ser command + arg o command + << DELIMITER + arg (los arg de command siguen la regla de separador)
					â†’ command + << LIMITER	
						âœ…	ls << LIMITER	
					â†’ command + argument/s + << LIMITER
						âœ… 	ls -l << LIMITER
					â†’ command + << LIMITER + argument/s (hasta separador)
						âœ… 	ls << LIMITER -l
						âŒ 	ls << LIMITER echo hola
							âŒ BASH_ERROR:
							ls: cannot access 'echo': No such file or directory
							ls: cannot access 'hola': No such file or directory 
					â†’ dobles heredoc' y sus combinaciones:  << LIMITER << LIMITER2

				â†’ Comillas solas sin un comando vÃ¡lido: el comando dentro de comillas no es valido â†’  âŒ BASH_ERROR
					â†’ ""
					â†’ ''
					â†’ " "
					â†’ ' '
				â†’ Solo operadores sin comando vÃ¡lido antes del separador/pipe. no encuentra el comando antes del separador â†’  âŒ BASH_ERROR
					â†’ |
					â†’ && echo hola
				â†’ si el comando es valido + "algo con comillas sin espacios" 	-> entre comillas siempre ira el argumento/s( variabes con extencion, agrumento de echo, path_naeme, etc. )
				â†’ si el comando no es valido					-> entre comillas se revisa como comando, quitando las comillas. Ver caso de comillas + espacios, a continuaciÃ³n y REGLAS DE TOKENIZACION CON COMILLAS. 
					â†’ "ls" == ls 		â†’ âœ… FUNCIONA: se ejecuta y se comporta igual que ls sin comillas
					â†’ 'env' == env 		â†’ âœ… FUNCIONA: se ejecuta y se comporta igual que env sin comillas	
					â†’ "touch"			â†’ âœ… FUNCIONA: se tokeniza como comando pero falla al no encontrar el argumento de su patron: command + file_operand
				â†’ si el argumento no es valido â†’ âŒ BASH_ERROR
					â†’ ls "-l -1"
				â†’ Excepciones:
					â†’ linea vacia: <espacio><espacio><ENTER> â†’ No hay tokens, asÃ­ que no hay comando. Bash simplemente muestra un nuevo prompt sin ejecutar nada.

			âœ” Las comillas permiten que los argumentos con espacios se traten como un solo token y anulan los separadores

			âœ” comillas abiertas 
				â†’ patron comando es el primer token: lo mismo para ' y "
					â†’ |' y &&' y &' y ||' y |&'  â†’ espera un comando antes del separador especial 		â†’ âŒ BASH_ERROR
					â†’ | algo " 																			â†’ âŒ BASH_ERROR
					â†’ '| y '&& y '|| 																	â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
					â†’ >|' y '>|	y '$| y $|'																â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
				â†’ patron redireccion: lo mismo para ' y "
					â†’ <' y >' y '< y '>  y lo mismo con >> y << 		â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
					â†’ ls >' test.txt									â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
					â†’ ls >" test.txt									â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
					â†’ << 'LIMITER y << LIMITER '						â†’ âŒ SINTAX_ERROR â†’ comillas ebiertas
				â†’ pipe "abierto" como comillas abiertas:
					â†’ echo hola |

			âœ” comillas CERRADAS dentro de un potencial comando:
				â†’ ech"o" hola 		â†’ âœ… FUNCIONA: â†’ tokeniza echo como comando y hola como argumento, el separador es espacio sin comillas
				â†’ echo"ho"la 		â†’ âŒ BASH_ERROR: â†’ echohola: command not found  â†’ tokeniza todo y lo manda como command, no hay separador
				â†’ echo "ho"la 		â†’ âœ… FUNCIONA: â†’ tokeniza echo como command y hola como argument, el separador es espacio sin comillas
				â†’ echo"ho "la 		â†’ âŒ BASH_ERROR: â†’ echoho la: command not found  â†’ no hay espacio sin comillas como separador y se tokeniza todo, espacio encomillado incluido
				â†’ echo"ho " la 		â†’ âŒ BASH_ERROR: â†’ echoho : command not found  â†’ tokeniza command hasta el espacio sin comillas

			âœ” Si no hay un espacio entre las comillas, el shell las concatena sin separarlas.  
				âŒ ERROR: "ls""-l""-1"|"wc""-l" â†’ ["ls-l-1", "|", "wc-l"]
				âœ… FUNCIONA:   "ls" "-l" -1|"wc" -l ["ls", "-l", "|", "wc", "-l"]
			âœ” Todo lo que sigue despuÃ©s del comando se considera argumento, hasta que aparezca un separador (|, ;, &&, ||, etc.).
				1. si metemos un separador entre comillas bash no quita las comillas y no interpretara ese separados como "separador", como pasa con los comandos y argumentos. 
			âœ” Si un comando o argumento queda mal formado despuÃ©s de la expansiÃ³n de comillas, el shell lo trata como un Ãºnico token no vÃ¡lido.
			âœ” Las comillas tambiÃ©n pueden ser manipuladas mediante el carÃ¡cter de escape (\).
			âœ” La expancion de variables se define con " o ' y se puede anular con \:  (ver mas detalles abajo: expancion de variables). Hay que tenerlo en cuenta a la hora de quitar las comilals de las variebles y tokenizar $VAR "limpia"
				'$VAR' 		â†’ no se expande
				"$VAR" 		â†’ se expande
				"\$VAR" 	â†’ no se expande

				1. Comillas y espacios combinados: si un argumento tiene espacios pero estÃ¡ rodeado por comillas, el shell lo considera como una Ãºnica palabra.
					â†’ "ls -l" 	 		â†’ âŒ BASH_ERROR:: se ejecuta como comando y se comporta: ls -l: command not found
					â†’ "ls " 	 		â†’ âŒ BASH_ERROR: se ejecuta como comando y se comporta: Command 'ls ' not found, did you mean: ...

				2. Comillas dobles ("): Lo que estÃ¡ dentro se trata como un "Ãºnico argumento" (vex explicaion anterior sobre comando o arguemnto entre comillas), respetando espacios, pero las variables y los comandos dentro se expanden. Ejemplo: "ls -l".
					
					'mi nombre es $USER' â†’ se clasificara como comando sin expancion	â†’ mi nombre es \$USER: command not found
					"mi nombre es $USER" â†’ se clasificara como comando con expancion	â†’ mi nombre es mzolotar: command not found

				3. Comillas simples ('): Todo dentro de las comillas simples es tratado literalmente, sin expansiÃ³n de variables o comandos.

					"$USER" â†’ "entre comillas" se clasificara como comando con expanciÃ³n		â†’ $USER se expande  			â†’	 mzolotar: command not found
					$USER  â†’  se clasificara como comando con expanciÃ³n							â†’ $USER se expande  			â†’	 mzolotar: command not found
					'$USER' â†’ 'entre comillas' se clasificara como comando con expanciÃ³n		â†’ $USER no se expande  			â†’	 $USER: command not found
				
				4. Comillas dentro de comillas: El carÃ¡cter de escape (\) permite que las comillas dobles dentro de la cadena sean parte del texto, no un delimitador.
					echo "mi nombre es \$USER" â†’ "entre comillas" se clasificara como argumento de echo	â†’ $USER no se expandira por \ 			â†’	mi nombre es $USER
					echo "mi nombre es $USER"  â†’ "entre comillas" se clasificara como argumento de echo	â†’ $USER se expandira por " 				â†’	mi nombre es mzolotar
					echo 'mi nombre es \$USER' â†’ "entre comillas" se clasificara como argumento de echo	â†’ $USER no se expandira por '   		â†’	mi nombre es \$USER

					si no tenemos echo $USER se considerara como comando y seguiras el mismo patron de expancion que se ejemplifica antes. 

	ğŸ”¸ 3. IdentificaciÃ³n de operadores especiales (primero el mas largo y luego los unitarios: <<<, <<, < o ||, |).
		1. Si el shell encuentra estos operadores juntos (|| o &&), los trata como un solo token, a menos que haya un separador forzado. 
		Si estan sin separar por un espacio o comillas o separadores, shell los separa/tokeniza priorizando la regla de revisar operadores de mas largo a mas corto.

			ls|||wc -l	â†’	["ls", "||", "|", "wc", "-l"].

			Operadores de mÃ¡s de un carÃ¡cter (||, &&) se reconocen como un solo token automÃ¡ticamente, de mas largo a mas corto: <<<, << y luego <.
				&&	â†’ AND lÃ³gico â†’ Ejecuta el segundo comando solo si el primero tiene Ã©xito.
				||	â†’ operador lÃ³gico de "OR â†’ Se usa para ejecutar un comando solo si el comando anterior falla, es decir, solo si el primer comando devuelve un cÃ³digo de salida diferente de 0 (lo que indica un error o fallo).
				;;	â†’ Fin de un caso en case â†’ Marca el final de una opciÃ³n en una estructura case.
				>>>	â†’ No vÃ¡lido pero se tokeniza como >> y >.
				<<	â†’ Here-Document â†’ Redirige mÃºltiples lÃ­neas de entrada a un comando.
				<<-	â†’ Here-Document con eliminaciÃ³n de tabulaciones â†’ Elimina tabulaciones antes de las lÃ­neas de entrada en un here-document.
				&>	â†’ RedirecciÃ³n de salida y error estÃ¡ndar (Bash).

				>|	â†’ pipe_type_especial
				|&	â†’ pipe_type_especial
				$|	â†’ pipe_type_especial

				diferentes tipos de redirecciones ver & combinado, mÃ¡s adelante. 
				
		2. Los operadores especiales (|, >, <, &) siempre se separan como tokens aunque no tengan espacio y aunque vallan a continuacion de operadores especiales. 
				| â†’ Pipe: Redirige la salida estÃ¡ndar de un comando al siguiente comando en la secuencia.
				> â†’ RedirecciÃ³n de salida: Redirige la salida estÃ¡ndar de un comando a un archivo.
					â†’ ver patrones de como se define lo que va despues de redireccion y como se limitan los arg. 
				< â†’ RedirecciÃ³n de entrada: Redirige la entrada estÃ¡ndar de un archivo a un comando.
					â†’ ver patrones de como se define lo que va despues de redireccion y como se limitan los arg.
				
				; â†’ Separador de comandos: Permite ejecutar mÃºltiples comandos en la misma lÃ­nea, uno tras otro.
				& â†’ Ejecutar en segundo plano: Se utiliza para ejecutar un comando en segundo plano.
					el & no se considera un separador de comandos en Bash, pero sÃ­ es un operador especial que tiene un significado diferente dependiendo de su contexto.
						â†’ Cuando usas el & al final de un comando, el comando se ejecuta en segundo plano (asÃ­ncrono) â†’ sleep 5 &
						â†’ Si & aparece junto con otros operadores como && o &>, su significado cambia. Por ejemplo:
							â†’ && es un operador lÃ³gico de "AND" que ejecuta el segundo comando solo si el primero tiene Ã©xito.
							â†’ &> es un operador de redirecciÃ³n de salida y error estÃ¡ndar.

			ejemplo:
			ls|||wc -l 					âŒ BASH_ERROR:
			TokenizaciÃ³n: ["ls", "||", "|", "wc", "-l"]
				ls â†’ Comando
				|| â†’ Operador OR lÃ³gico
				| â†’ Pipe (redirige la salida de || a wc, lo cual es incorrecto)
				Error de sintaxis: El operador || no produce salida, por lo que no se puede encadenar con |.
				Resultado: El shell muestra un error de sintaxis -> âŒ BASH_ERROR:

	ğŸ”¸ 4. AgrupaciÃ³n de caracteres entre comillas: Si los caracteres estÃ¡n entre comillas, el shell los agrupa y los trata como un Ãºnico token.
	ğŸ”¸ 5. ExpansiÃ³n de variables y sustituciÃ³n de comandos. OJO al menejar tipos de varibles en C. En caso de expandirse habra que ver que tipo de varieble es para almacenarlade forma correcta y usarla despues con tipo correcto. 
			0. localizar la variable:
				â†’ la varieble sera:
					â†’ $+primer_char:
						$_
						$a (alfa minusculas)
						$A (alfa mayusculas)
				â†’ los siguientes caracteres despues de $+[0] -> la variable puede tener:
					â†’ alfanumericos (alfanum may y min) y barras bajas
				â†’ la varieble termina si:
					â†’ no repseta las dos reglas anteriores
					â†’ hay espacio o caracter no permitido por las dos reglas anteriores
				â†’ la variable sera ' ' si '$ ' â†’ por las reglas anteriores. y combinaciones varias: $-, $;, $; 
				â†’ caso en los que la exp de variable o contenido de varieable da âŒ SINTAX_ERROR:  ver expancino de variebles pto. 5.1 ExpansiÃ³n de variables. 
					
			1. varible sin comillas 
				si respeta las reglas anteriores la varieble se espande. 
			2. variable con '
				â†’ echo '$USER' â†’ no se expande por '
			3. variable con "
				â†’ echo "$USER" â†’ se expande por "
			4. cosos especiales " '$VAR'" -> ver priodad de comillas. expnacion y mantien una de las comillas en la tokenizacion:
				â†’ echo "'$USER'" â†’ se expande, mandan las comillas ""					 â†’ 'mzolotar'
				â†’ echo '"$USER"' â†’ no se expande, mandan las comillas ''				 â†’ "$USER"
		1. ExpansiÃ³n de variables: Las expansiones de variables ocurren cuando se sustituyen las referencias a variables en un comando o expresiÃ³n con sus valores actuales, Tipos de expanciÃ§on de variebles en BASH:
			0. $? â†’ es una variable especial que almacena el cÃ³digo de salida (exit status) del Ãºltimo comando ejecutado.
				 â†’ Si el valor de $? es 0, significa que el Ãºltimo comando se ejecutÃ³ correctamente.
				 â†’ Si el valor de $? es distinto de 0, significa que hubo un error. Los diferentes valores indican distintos tipos de errores.
				 â†’ En Bash, el cÃ³digo de salida almacenado en $? tiene un rango de 0 a 255.
					 â†’ 0 â†’ Indica que el comando se ejecutÃ³ con Ã©xito.
					 â†’ 1-255 â†’ Indican diferentes tipos de errores o estados de salida.
					 	 â†’ 1 - Error general
						 â†’ 2 - Uso incorrecto de shell builtins
						 â†’ 126 - Comando encontrado pero no ejecutable
						 â†’ 127 - Comando no encontrado
					 â†’ 256 o valores mayores â†’ Se truncan al rango 0-255 (porque Bash usa un byte para el cÃ³digo de salida).
				 â†’ Para establecer tu propio cÃ³digo de error en Bash, usa el comando exit <cÃ³digo>. Si quieres un cÃ³digo estÃ¡ndar, puedes usar 2 para SYNTAX_ERROR, ya que Bash usa 2 para errores de uso (misuse of shell builtins).
					ğŸ”´ Evitar conflictos con cÃ³digos de Bash
							 â†’ Valores 1-125 son seguros para errores personalizados.
							 â†’ Valores 126-127 estÃ¡n reservados por Bash:
								 â†’ 126: No tienes permisos para ejecutar un script.
								 â†’ 127: Comando no encontrado.
							 â†’ 128+ estÃ¡n reservados para seÃ±ales (kill -9 â†’ exit 137).
			1. âœ… ExpansiÃ³n de variables (Variable Expansion): Esto es simplemente la sustituciÃ³n de una variable por su valor.
				variable="Hola"
				echo $variable
				output: Hola
			2. âœ… ExpansiÃ³n de parÃ¡metros (Parameter Expansion):Esto incluye el uso de las variables del entorno, como $HOME, $PATH, etc.
				echo $HOME
				output: /home/user
			3. âŒ ExpansiÃ³n de la variable con el prefijo ${}: Se usa para referirse a variables de una forma mÃ¡s explÃ­cita.
				-> (âŒ SINTAX_ERROR)
				nombre="Juan"
				echo "Hola ${nombre}"
				output: Hola Juan
			4. âœ…  ExpansiÃ³n de comandos: Permite ejecutar un comando dentro de un valor, y sustituir esa parte del comando con su salida.
				-> (âŒ SINTAX_ERROR) quitamos las comillas
				echo "La fecha de hoy es: $(date)"
				echo "lista de archivos: $(ls -1)"
				
				âœ…  CMD_VAR="ls -l"
					-> funcion para expandir las vars
			5. âŒ ExpansiÃ³n aritmÃ©tica: Se usa para realizar operaciones matemÃ¡ticas dentro de un comando.
				-> (âŒ SINTAX_ERROR)
				echo $((5 + 3))
				output: 8
			6. âŒ ExpansiÃ³n de arreglos: Si usas variables tipo arreglo, puedes expandir sus elementos.
				-> (âŒ SINTAX_ERROR)
				array=("uno" "dos" "tres")
				echo ${array[1]}
				output: dos
			7. âœ… ExpansiÃ³n de la tilde (~): Se usa para hacer referencia al directorio home del usuario.
				cd ~ 			â†’ Te lleva al directorio home del usuario.
			8. âŒ ExpansiÃ³n de comodines (Globbing): Utiliza patrones como *, ?, y [] para coincidir con nombres de archivos en el sistema.
				-> (âŒ SINTAX_ERROR)
				ls *.txt			â†’ Esto lista todos los archivos con la extensiÃ³n .txt.
				
			
	ğŸ”¸ 6. ExpansiÃ³n de comodines (Globbing: * â†’ (*.txt), ? â†’ (file?.txt), [] â†’ (file[123].txt), {} â†’ (file{1,2,3}.txt)) == wildcards)
		-> (âŒ SINTAX_ERROR)
	ğŸ”¸ 7. Reconocimiento de redirecciones (>, <, >>, 2>, etc.)
			â†’  âœ… <, <<, >, >>
				â†’ casos con 1 redireccion.
					â†’ comando + redireccion + path_name:
						â†’ ls > list.txt
					â†’ redirecciÃ³n + path_name:
						â†’ > test.txt
				â†’ casos con varias redirecciones encadenadas.
					âŒ ls > test.txt main.c > test2.txt 				-> command + > + path_name/file_name + argumento de ls + > path_name/file_name: en este caso la segunda resireccion cogera el argumento de ls como texto plano, no como comando
					âŒ ls > test.txt main.c > test2.txt  
					âœ… ls main.c | tee test.txt test2.txt
			â†’  âŒ las demas redirecciones 
				-> (âŒ SINTAX_ERROR)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 2.0 ExpansiÃ³n: AquÃ­ es cuando las variables son sustituidas por sus valores. 
En el paso 2 de tokenizaciÃ³n, las expansiones de variables y comandos ocurren antes del parsing (anÃ¡lisis sintÃ¡ctico). 
Esto asegura que los valores correctos se sustituyan antes de analizar la estructura de los comandos.

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 2. Parsing (AnÃ¡lisis SintÃ¡ctico): El parser toma la lista de tokens y los agrupa en estructuras segÃºn la gramÃ¡tica de Bash.
	ğŸ”¸ 1. Reconoce comandos y argumentos (valiso y no validos por subject_minishell)
		1. El shell examina el primer token despuÃ©s de la tokenizaciÃ³n:
			1. Si es un operador especial (|, >, <, <<, ;, &), se trata como un operador y no como un comando. 
			2. Si es una palabra sin comillas ni operadores, el shell intenta encontrar un comando ejecutable con ese nombre. 
			Todo lo que sigue despuÃ©s del primer token es considerado un argumento, hasta que aparece un operador lÃ³gico o separador que indique la separaciÃ³n entre comandos. 
			Comandos encadenados: Si hay un operador lÃ³gico como &&, ||, ;, etc., el shell lo interpreta como un separador, y lo que sigue despuÃ©s del operador es un nuevo comando, no un argumento.
				1. CÃ³mo el shell verifica si el primer token es un comando? El shell busca el comando en este orden:
					1. Alias: Comprueba si el token es un alias definido por el usuario (alias ll='ls -l').
						-> (âŒ SINTAX_ERROR) en fase de tokenizaciÃ³n. 
					2. Palabras clave de shell: Comprueba si es un comando interno (if, for, while, echo).
						1. comando interno que va a âŒ SINTAX_ERROR:
							1. if, for, while, etc
							2. 
						2. comando interno que va a ejecucion:
							1. /bin/command
							2. comandos propios: echo, cd, pwd, export, unset, env, exit
					3. Funciones de shell: Comprueba si el usuario definiÃ³ una funciÃ³n con ese nombre.
						âŒ SINTAX_ERROR
					4. Comandos internos (builtins): Verifica si es un comando incorporado en el shell (cd, exit, set).
					5. Comandos en el $PATH	
						1. Busca en los directorios listados en la variable de entorno $PATH.
						2. Si encuentra un binario con ese nombre, lo ejecuta.
						3. Si no lo encuentra, muestra un error
				
		3. Todo lo que viene despuÃ©s del primer comando se considera un argumento, opciÃ³n, o archivo hasta que aparece un operador especial.
		4. Casos especiales: AmbigÃ¼edades y prefijos
			1. Comando con el mismo nombre que un archivo:
			2. Uso de rutas relativas o absolutas:
			3. Uso de command, builtin, y type para verificar comandos:
	ğŸ”¸ 2. Construye estructuras sintÃ¡cticas
	ğŸ”¸ 3. Detecta redirecciones
	ğŸ”¸ 4. Manejo de subprocesos y agrupaciones
	ğŸ”¸ 5. SustituciÃ³n de comandos ($(cmd), `cmd`) -> echo "Hoy es $(date)"


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 4. ExpansiÃ³n (Expansion Phase)
	ğŸ”¸ 1. ExpansiÃ³n de variables
	ğŸ”¸ 2. ExpansiÃ³n de comandos
	ğŸ”¸ 3. ExpansiÃ³n de aritmÃ©tica
	ğŸ”¸ 4. ExpansiÃ³n de comodines (Globbing)
	ğŸ”¸ 5. ExpansiÃ³n de tilde (~)
	ğŸ”¸ 6. ExpansiÃ³n de separaciÃ³n de palabras (IFS)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
â­ 5. âŒ SINTAX_ERROR de los token "limpios":
	1. Ver si hay operadores no autorizados por subject y que NO van a ir a ejecucion	 -> âŒ SINTAX_ERROR
		1. siga o no siga el patron de BASH [algo] [not_allow_aoperator] [algo] 		-> âŒ SINTAX_ERROR
		2. token tiene metachar_not_allow 												-> âŒ SINTAX_ERROR
		3. token tiene not_allow_bracket (ver variebles) 								-> âŒ SINTAX_ERROR
		4. \ en expancion de var y \ en general -> revisar esta parte
		5. 
		6. 
	2. ver si hay operadores no autorizados que en teoria tiran âŒ BASH_ERROR pero lo paramos en âŒ SINTAX_ERROR
		1. 
		2. 
		3. 
	3. ver si hay operadores no autorizados pero deben ir a ejecucion para tirar âŒ BASH_ERROR. 
		1. 
		2. 
		3.
		4. 
		5. 

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
â­ 6. EjecuciÃ³n del Comando
		ğŸ”¸ 1. Determina el tipo de comando
				1. Comando interno: ejecutado por Bash (ej. cd, echo, export).
				2. Comando externo: busca en $PATH y ejecuta el binario correspondiente.
		ğŸ”¸ 2. Crea un proceso (si es necesario)
		ğŸ”¸ 3. Manejo de redirecciones
		ğŸ”¸ 4. Espera la finalizaciÃ³n del comando


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 7. Manejo del Estado de Salida


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 8. Guarda el comando en el historial:

	VER LOS COMANDOS QUE SE GUARGAN O NO EN EL HISTORIAL
	VER COMO SE SOBREESCRIBE EN EL HISTORIAL
	ğŸ”¸ 1. 
	ğŸ”¸ 2.

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

â­ 9. Muestra el nuevo prompt (PS1) â†’ Espera la siguiente entrada.


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢##â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢##â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

//#âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ”€â¤âµâ€¢âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ”€â”€ DEFENSA: â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ¤âµâ€¢âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ”#

1. ver hoja DEFENSA
2. 2 heredoc seguidos
3. echo "hello from file 4" >file1 >file2 > file3 >>file4 | cat <<eof << "end " <file4	
4. Prueba todos los posibles syntax error como comillas abiertas, pipe al inicio o al final etc
5. Haz carpetas dentro de carpetas y muÃ©vete dentro, que estÃ©s 

~/carpeta1/carpeta2/carpeta3

Borra la 1
rm -r ../../../carpeta1

Haz pwd
Luego cd..

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢TOKENIZACION comando defensaâ€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

coamndo de defensa: echo "hello from file 4" >file1 >file2 > file3 >>file4 | cat <<eof << "end " <file4	


echo "hello from file 4" >file1 >file2 > file3 >>file4

ğŸ“Œ Paso 1: TokenizaciÃ³n
â†’ echo						â†’ Comando
â†’ "hello from file 4"		â†’ Argumento del comando
â†’ >							â†’ RedirecciÃ³n de salida
â†’ file1						â†’ Archivo de salida
â†’ >							â†’ RedirecciÃ³n de salida
â†’ file2						â†’ Archivo de salida
â†’ >							â†’ RedirecciÃ³n de salida
â†’ file3						â†’ Archivo de salida
â†’ >>						â†’ RedirecciÃ³n de salida en modo append
â†’ file4						â†’ Archivo de salida

ğŸ“Œ Paso 2: InterpretaciÃ³n en Bash
		1. echo "hello from file 4" genera la salida estÃ¡ndar:

			hello from file 4

		2. Redirecciones en orden:
			> file1 crea (o vacÃ­a si ya existe) file1, pero la salida aÃºn no se escribe.
			> file2 redirige la salida a file2, sobrescribiendo file1.
			> file3 redirige la salida a file3, sobrescribiendo file2.
			>> file4 redirige la salida a file4 en modo append (se aÃ±ade al final del archivo sin sobrescribirlo).

		3. La salida final ("hello from file 4") se escribe en file3 y file4.


ğŸ“Œ Â¿QuÃ© sucede con los archivos?
â†’  file1, file2 y file3 se crean, pero solo file3 recibe el texto.
â†’  file4 mantiene su contenido previo y aÃ±ade "hello from file 4" al final.
â†’  file1 y file2 estarÃ¡n vacÃ­os porque las redirecciones sucesivas los sobreescriben, pero nunca reciben datos

âœ… ConclusiÃ³n:
â†’  Bash sigue la redirecciÃ³n de derecha a izquierda.
â†’  Solo el Ãºltimo archivo (file3) recibe la salida estÃ¡ndar, antes de que se duplique en file4.

ğŸ”¹ Si quieres escribir en todos los archivos al mismo tiempo, usa tee: 
	echo "hello from file 4" | tee file1 file2 file3 file4

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢##â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢##â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#


//#âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ”€â¤âµâ€¢âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ”€â”€ TOKENIZACION DE COMANDOS: â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ¤âµâ€¢âµâ¤â”€â”€â•Œâ•Œâ£â‹†â£â•Œâ•Œâ”#

1. cd ..

Tokens:
cd (command)
.. (argument)
#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

2. echo Hello, World!

Tokens:
echo (command)
Hello, (argument)
World! (argument)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
3.1 echo "This is a 'test'"

Tokens:
echo (comando)
"This is a 'test'" (argumento, tratado como una sola unidad debido a las comillas dobles)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
3.2 echo 'This is a "test"'

Tokens:
echo (comando)
'This is a "test"' (argumento, tratado como una sola unidad debido a las comillas simples)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
4.1 echo 'Hello $USER'

Tokens:
echo (comando)
'Hello $USER' (argumento, sin expansiÃ³n de $USER porque estÃ¡ entre comillas simples)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
4.2 echo "Hello $USER"

Tokens: 
echo (comando)
"Hello $USER" (argumento, $USER se expandirÃ¡ porque estÃ¡ entre comillas dobles)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

4.3  VAR="world"
Tokens:
VAR="world" â†’ AsignaciÃ³n de variable (un solo token, sin separaciÃ³n)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
4.4 VAR="hello world"

Tokens:
VAR="hello world" (un solo token, incluyendo el espacio dentro de las comillas)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
5. 
VAR="world"
echo "Hello $VAR"   
echo 'Hello $VAR'

Comando: VAR="world"
Tokens: VAR=world (asignaciÃ³n de variable, sin espacios alrededor del =)

Comando: echo "Hello $VAR"
Tokens:
echo (comando)
"Hello $VAR" (argumento, $VAR se expandirÃ¡)

Comando: echo 'Hello $VAR'
Tokens:
echo (comando)
'Hello $VAR' (argumento, $VAR no se expandirÃ¡ porque estÃ¡ entre comillas simples)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
5.1

echo "var  $ARG=2" (se expande) -> output: var   2
echo "var  $ARG = 2"  (se expande) -> output: var   = 2
echo 'var  $ARG =2' (no se expande) -> output: var  $ARG =2
echo 'var  $ARG=2' (no se expande) -> output: var  $ARG=2


-Comando: echo "var $ARG=2"

Tokens:
echo (comando)
"var $ARG=2" (argumento, $ARG se expandirÃ¡ porque estÃ¡ entre comillas dobles)

-Comando: echo "var $ARG = 2"

Tokens:
echo (comando)
"var $ARG = 2" (argumento, $ARG se expandirÃ¡ porque estÃ¡ entre comillas dobles)


-Comando: echo 'var $ARG =2'

Tokens:
echo (comando)
'var $ARG =2' (argumento, $ARG no se expandirÃ¡ porque estÃ¡ entre comillas simples)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.2 ls -l "$DIR"
Tokens:

ls (comando)
-l (opciÃ³n)
"$DIR" (argumento, $DIR se expandirÃ¡ porque estÃ¡ entre comillas dobles)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.3 archivo="datos.txt" cat "$archivo"

Tokens:
archivo="datos.txt" (asignaciÃ³n de variable, archivo se establecerÃ¡ en "datos.txt")
cat (comando)
"$archivo" (argumento, $archivo se expandirÃ¡ porque estÃ¡ entre comillas dobles)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.4 echo "Hola $USER"

Tokens:
echo (comando)
"Hola $USER" (argumento, $USER se expandirÃ¡ porque estÃ¡ entre comillas dobles)


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.5 nombre="Carlos"

Tokens:
nombre="Carlos" (asignaciÃ³n de variable, nombre se establecerÃ¡ en "Carlos")

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.6 grep "$PATTERN" file.txt

Tokens:
grep (comando)
"$PATTERN" (argumento, $PATTERN se expandirÃ¡)
file.txt (argumento)


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.7 cat $FILE

Tokens:
cat (comando)
$FILE (argumento, se expandirÃ¡ al valor de la variable)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.8 mv "$SRC" "$DEST"

Tokens:
mv (comando)
"$SRC" (argumento, $SRC se expandirÃ¡)
"$DEST" (argumento, $DEST se expandirÃ¡)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

5.9 export PATH="$HOME/bin:$PATH"

Tokens:
export (comando)
PATH="$HOME/bin:$PATH" (asignaciÃ³n de variable, $HOME y $PATH se expandirÃ¡n)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

9.10 touch "$FILENAME"

Tokens:
touch (comando)
"$FILENAME" (argumento, $FILENAME se expandirÃ¡)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
 9.11 echo "$USER is logged in"

Tokens:
echo (comando)
"$USER is logged in" (argumento, $USER se expandirÃ¡)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

9.12 cp "$SOURCE" "$TARGET"

Tokens:
cp (comando)
"$SOURCE" (argumento, $SOURCE se expandirÃ¡)
"$TARGET" (argumento, $TARGET se expandirÃ¡)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

9.13 find . -name "$PATTERN"

Tokens:
find (comando)
. (argumento)
-name (opciÃ³n)
"$PATTERN" (argumento, $PATTERN se expandirÃ¡)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
6. echo "Hello, world!" > "output file.txt"

Tokens:
echo (comando)
"Hello, world!" (argumento)
> (operador de redirecciÃ³n)
"output file.txt" (archivo de salida, tratado como un solo token debido a las comillas)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
7. cat testfile.txt | grep "pattern" | wc -l > count.txt

Tokens:
cat (command)
testfile.txt (argument)
| (pipe)
grep (command)
"pattern" (argument, treated as a single token due to quotes)
| (pipe)
wc (command)
-l (argument)
> (redirection operator)
count.txt (file for redirection)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
8. echo "Hello World" | tr ' ' '\n' | sort

Tokens:
echo (command)
"Hello World" (argument, treated as a single token due to quotes)
| (pipe)
tr (command)
' ' (argument, single-quoted space)
'\n' (argument, single-quoted newline)
| (pipe)
sort (command)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#
9. ls | grep .txt | xargs wc -l

Tokens:
ls (command)
| (pipe)
grep (command)
.txt (argument)
| (pipe)
xargs (command)
wc (command)
-l (argument)


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#


10. Comando: echo "He said: \"Hello!\""

Tokens:
echo (command)
"He said: \"Hello!\"" (argument, las comillas dobles permiten la expansiÃ³n de variables y caracteres especiales escapados con \)

Outut shell:

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

10.1. Comando: echo 'He said: "Hello!"'

Tokens:
echo (command)
'He said: "Hello!"' (argument, las comillas simples preservan todo el contenido literal, sin expansiÃ³n de variables ni caracteres especiales)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

10.2 Comando: echo 'He said: \'Hello!\''

Tokens:
echo (command)
âŒ Error de sintaxis, porque dentro de comillas simples '...' no se puede usar \' para escapar otra comilla simple.
CorrecciÃ³n vÃ¡lida: echo 'He said: '"'"'Hello!'"'"'
Tokens corregidos:
echo (command)
'He said: ' (argument, primera parte de la cadena en comillas simples)
'"'"' (argument, comilla simple dentro de comillas dobles para permitir la inclusiÃ³n de ')
'Hello!' (argument, segunda parte de la cadena en comillas simples)


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

11.0 echo "|"

Tokens:
echo (command)
| (argument)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

11.1 echo '|'

Tokens:
echo (command)
| (argument)


#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

11.2 ls | grep .txt 

Tokens:
ls (command)
| (pipe)
grep (command)
.txt (argument)

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

11.3 ls "|" grep .txt y ls '|' grep .txt

ls (command)
| (argument)

ls: cannot access '|': No such file or directory 
ls: cannot access 'grep': No such file or directory
ls: cannot access '.txt': No such file or directory

#â€¢â…â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€â…â€¢â€¢â…â”€â”€â…â€¢â€¢â…â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â”€âœ§â…âœ¦â…âœ§â”€â”€â”€â”€â”€â…â€¢#

11.4 

echo \n         -> n
echo "\n"       -> \n
echo '\n'       -> \n



